"""Very small loader that writes the summary table into PostgreSQL."""

from __future__ import annotations

import os
from typing import Dict, Iterable, Sequence, Tuple

import pandas as pd
import psycopg2
from psycopg2.extensions import connection as PGConnection
from psycopg2.extras import execute_values

# Default connection details. Override them with POSTGRES_* environment variables
# if your database uses different values.
DEFAULT_SETTINGS: Dict[str, str] = {
    "POSTGRES_HOST": "127.0.0.1",
    "POSTGRES_PORT": "5432",
    "POSTGRES_DATABASE": "etl_db",
    "POSTGRES_USER": "etl_user",
    "POSTGRES_PASSWORD": "etl_password",
}


def get_database_settings() -> Dict[str, str]:
    """Collect simple connection settings from the environment."""

    settings = {
        name: os.getenv(name, default) for name, default in DEFAULT_SETTINGS.items()
    }
    return settings


def create_connection() -> PGConnection:
    """Open a psycopg2 connection using the collected settings."""

    settings = get_database_settings()
    return psycopg2.connect(
        dbname=settings["POSTGRES_DATABASE"],
        user=settings["POSTGRES_USER"],
        password=settings["POSTGRES_PASSWORD"],
        host=settings["POSTGRES_HOST"],
        port=settings["POSTGRES_PORT"],
    )


def load_order_summary(connection: PGConnection, summary: pd.DataFrame) -> None:
    """Drop and recreate the order_summary table, then insert the rows."""

    rows = [
        (
            int(row.order_id),
            row.order_date.date(),
            int(row.customer_id),
            row.customer_name,
            float(row.order_total),
        )
        for row in summary.itertuples(index=False)
    ]

    with connection:
        with connection.cursor() as cursor:
            cursor.execute("DROP TABLE IF EXISTS order_summary;")
            cursor.execute(
                """
                CREATE TABLE order_summary (
                    order_id INTEGER PRIMARY KEY,
                    order_date DATE,
                    customer_id INTEGER,
                    customer_name TEXT,
                    order_total NUMERIC
                );
                """
            )
            cursor.executemany(
                """
                INSERT INTO order_summary (
                    order_id, order_date, customer_id, customer_name, order_total
                ) VALUES (%s, %s, %s, %s, %s);
                """,
                rows,
            )
            print(f"Saved {len(rows)} rows to the order_summary table.")


TABLE_COLUMNS: Dict[str, Sequence[str]] = {
    "brands": ("brand_id", "brand_name"),
    "categories": ("category_id", "category_name"),
    "stores": (
        "store_id",
        "store_name",
        "phone",
        "email",
        "street",
        "city",
        "state",
        "zip_code",
    ),
    "customers": (
        "customer_id",
        "first_name",
        "last_name",
        "email",
        "phone",
        "street",
        "city",
        "state",
        "zip_code",
    ),
    "products": (
        "product_id",
        "product_name",
        "brand_id",
        "category_id",
        "model_year",
        "list_price",
    ),
    "staffs": (
        "staff_id",
        "first_name",
        "last_name",
        "email",
        "phone",
        "active",
        "street",
        "store_id",
        "manager_id",
    ),
    "stocks": ("store_id", "product_id", "quantity"),
    "orders": (
        "order_id",
        "customer_id",
        "store_id",
        "staff_id",
        "order_status",
        "order_date",
        "required_date",
        "shipped_date",
    ),
    "order_items": (
        "order_id",
        "item_id",
        "product_id",
        "quantity",
        "list_price",
        "discount",
    ),
}


LOAD_ORDER: Sequence[str] = (
    "brands",
    "categories",
    "stores",
    "customers",
    "products",
    "staffs",
    "stocks",
    "orders",
    "order_items",
)


CREATE_TABLE_STATEMENTS: Sequence[str] = (
    """
    CREATE TABLE IF NOT EXISTS brands (
        brand_id INTEGER PRIMARY KEY,
        brand_name TEXT NOT NULL UNIQUE
    );
    """,
    """
    CREATE TABLE IF NOT EXISTS categories (
        category_id INTEGER PRIMARY KEY,
        category_name TEXT NOT NULL UNIQUE
    );
    """,
    """
    CREATE TABLE IF NOT EXISTS stores (
        store_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        store_name TEXT NOT NULL,
        phone VARCHAR(25),
        email TEXT,
        street TEXT NOT NULL,
        city VARCHAR(100) NOT NULL,
        state CHAR(2) NOT NULL,
        zip_code VARCHAR(10) NOT NULL,
        CONSTRAINT uk_stores_name UNIQUE (store_name)
    );
    """,
    """
    CREATE TABLE IF NOT EXISTS customers (
        customer_id INTEGER PRIMARY KEY,
        first_name VARCHAR(100) NOT NULL,
        last_name VARCHAR(100) NOT NULL,
        email TEXT NOT NULL,
        phone VARCHAR(25),
        street TEXT NOT NULL,
        city VARCHAR(100) NOT NULL,
        state CHAR(2) NOT NULL,
        zip_code VARCHAR(10) NOT NULL,
        CONSTRAINT uk_customers_email UNIQUE (email)
    );
    """,
    """
    CREATE TABLE IF NOT EXISTS products (
        product_id INTEGER PRIMARY KEY,
        product_name TEXT NOT NULL,
        brand_id INTEGER NOT NULL,
        category_id INTEGER NOT NULL,
        model_year SMALLINT NOT NULL,
        list_price NUMERIC(10, 2) NOT NULL,
        CONSTRAINT fk_products_brand
            FOREIGN KEY (brand_id) REFERENCES brands (brand_id)
            ON UPDATE CASCADE
            ON DELETE RESTRICT,
        CONSTRAINT fk_products_category
            FOREIGN KEY (category_id) REFERENCES categories (category_id)
            ON UPDATE CASCADE
            ON DELETE RESTRICT
    );
    """,
    """
    CREATE TABLE IF NOT EXISTS staffs (
        staff_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        first_name VARCHAR(100) NOT NULL,
        last_name VARCHAR(100) NOT NULL,
        email TEXT NOT NULL,
        phone VARCHAR(25),
        active BOOLEAN NOT NULL DEFAULT TRUE,
        street TEXT NOT NULL,
        store_id INTEGER NOT NULL,
        manager_id INTEGER,
        CONSTRAINT uk_staffs_email UNIQUE (email),
        CONSTRAINT fk_staffs_store
            FOREIGN KEY (store_id) REFERENCES stores (store_id)
            ON UPDATE CASCADE
            ON DELETE RESTRICT,
        CONSTRAINT fk_staffs_manager
            FOREIGN KEY (manager_id) REFERENCES staffs (staff_id)
            ON UPDATE CASCADE
            ON DELETE SET NULL
    );
    """,
    """
    CREATE TABLE IF NOT EXISTS stocks (
        store_id INTEGER NOT NULL,
        product_id INTEGER NOT NULL,
        quantity INTEGER NOT NULL DEFAULT 0,
        PRIMARY KEY (store_id, product_id),
        CONSTRAINT fk_stocks_store
            FOREIGN KEY (store_id) REFERENCES stores (store_id)
            ON UPDATE CASCADE
            ON DELETE CASCADE,
        CONSTRAINT fk_stocks_product
            FOREIGN KEY (product_id) REFERENCES products (product_id)
            ON UPDATE CASCADE
            ON DELETE RESTRICT
    );
    """,
    """
    CREATE TABLE IF NOT EXISTS orders (
        order_id INTEGER PRIMARY KEY,
        customer_id INTEGER NOT NULL,
        store_id INTEGER NOT NULL,
        staff_id INTEGER NOT NULL,
        order_status SMALLINT NOT NULL,
        order_date DATE NOT NULL,
        required_date DATE NOT NULL,
        shipped_date DATE,
        CONSTRAINT fk_orders_customer
            FOREIGN KEY (customer_id) REFERENCES customers (customer_id)
            ON UPDATE CASCADE
            ON DELETE RESTRICT,
        CONSTRAINT fk_orders_store
            FOREIGN KEY (store_id) REFERENCES stores (store_id)
            ON UPDATE CASCADE
            ON DELETE RESTRICT,
        CONSTRAINT fk_orders_staff
            FOREIGN KEY (staff_id) REFERENCES staffs (staff_id)
            ON UPDATE CASCADE
            ON DELETE RESTRICT
    );
    """,
    """
    CREATE TABLE IF NOT EXISTS order_items (
        order_id INTEGER NOT NULL,
        item_id INTEGER NOT NULL,
        product_id INTEGER NOT NULL,
        quantity INTEGER NOT NULL,
        list_price NUMERIC(10, 2) NOT NULL,
        discount NUMERIC(5, 2) NOT NULL DEFAULT 0.00,
        PRIMARY KEY (order_id, item_id),
        CONSTRAINT fk_order_items_order
            FOREIGN KEY (order_id) REFERENCES orders (order_id)
            ON UPDATE CASCADE
            ON DELETE CASCADE,
        CONSTRAINT fk_order_items_product
            FOREIGN KEY (product_id) REFERENCES products (product_id)
            ON UPDATE CASCADE
            ON DELETE RESTRICT
    );
    """,
)


CREATE_INDEX_STATEMENTS: Sequence[str] = (
    "CREATE INDEX IF NOT EXISTS idx_stores_state_city ON stores (state, city);",
    "CREATE INDEX IF NOT EXISTS idx_products_brand ON products (brand_id);",
    "CREATE INDEX IF NOT EXISTS idx_products_category ON products (category_id);",
    "CREATE INDEX IF NOT EXISTS idx_staffs_store ON staffs (store_id);",
    "CREATE INDEX IF NOT EXISTS idx_orders_customer ON orders (customer_id);",
    "CREATE INDEX IF NOT EXISTS idx_orders_store ON orders (store_id);",
    "CREATE INDEX IF NOT EXISTS idx_orders_staff ON orders (staff_id);",
)


IDENTITY_TABLES: Dict[str, str] = {
    "stores": "store_id",
    "staffs": "staff_id",
}


def _iter_rows(frame: pd.DataFrame, columns: Sequence[str]) -> Iterable[Tuple]:
    selected = frame.loc[:, list(columns)]
    for row in selected.itertuples(index=False, name=None):
        yield tuple(_coerce_db_value(value) for value in row)


def _coerce_db_value(value):
    if pd.isna(value):
        return None
    if isinstance(value, pd.Timestamp):
        return value.to_pydatetime()
    if hasattr(value, "item"):
        try:
            return value.item()
        except ValueError:
            pass
    return value


def _ensure_schema(cursor) -> None:
    """Create the relational schema if it does not already exist."""

    for statement in CREATE_TABLE_STATEMENTS:
        cursor.execute(statement)

    for statement in CREATE_INDEX_STATEMENTS:
        cursor.execute(statement)


def load_core_tables(connection: PGConnection, tables: Dict[str, pd.DataFrame]) -> None:
    """Truncate and reload all tables needed by the relational schema."""

    with connection:
        with connection.cursor() as cursor:
            _ensure_schema(cursor)
            cursor.execute(
                "TRUNCATE TABLE order_items, orders, stocks, staffs, products, "
                "customers, stores, categories, brands RESTART IDENTITY CASCADE;"
            )

            for table_name in LOAD_ORDER:
                frame = tables[table_name]
                columns = TABLE_COLUMNS[table_name]
                rows = list(_iter_rows(frame, columns))
                if not rows:
                    continue

                insert_sql = (
                    f"INSERT INTO {table_name} (" + ", ".join(columns) + ") VALUES %s"
                )
                execute_values(cursor, insert_sql, rows)
                print(f"Loaded {len(rows)} rows into {table_name}.")

            for table_name, column in IDENTITY_TABLES.items():
                cursor.execute(
                    "SELECT setval(pg_get_serial_sequence(%s, %s), "
                    "COALESCE(MAX("
                    + column
                    + "), 0) + 1, false) FROM "
                    + table_name
                    + ";",
                    (f"public.{table_name}", column),
                )


__all__ = [
    "create_connection",
    "load_core_tables",
    "load_order_summary",
    "get_database_settings",
]
